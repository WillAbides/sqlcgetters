package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/alecthomas/kong"
	"github.com/willabides/sqlcgetters"
)

var version string // set by linker

const description = `sqlcgetters generates getters for structs generated by sqlc.`

func main() {
	vars := kong.Vars{
		"version":     version,
		"VersionHelp": `Output the version and exit.`,
		"PathHelp":    `Path to sqlc output directory.`,
		"OutHelp":     `Output file. Default: stdout.`,
	}
	if vars["version"] == "" {
		vars["version"] = "dev"
	}
	var cli cliRoot
	kctx := kong.Parse(&cli, vars, kong.Description(description))
	kctx.FatalIfErrorf(kctx.Run())
}

type cliRoot struct {
	Out     string           `kong:"short=o,help=${OutHelp}"`
	Version kong.VersionFlag `kong:"help=${VersionHelp}"`
	Path    string           `kong:"arg,required,type=existingdir,help=${PathHelp}"`
}

func (c *cliRoot) Run(kctx *kong.Context) (err error) {
	fsys := os.DirFS(c.Path)
	sources, err := sqlcgetters.ListSQLCFiles(fsys, ".")
	if err != nil {
		return err
	}
	if len(sources) == 0 {
		return fmt.Errorf("no sqlc output found in %s", c.Path)
	}

	var buf bytes.Buffer
	_, err = sqlcgetters.GenerateGetters(&buf, fsys, sources...)
	if err != nil {
		return err
	}

	// default to stdout
	if c.Out == "" {
		_, err = io.Copy(kctx.Stdout, &buf)
		return err
	}

	// write file with permissions from parent dir minus executable bit
	dirInfo, err := os.Stat(filepath.Dir(c.Out))
	if err != nil {
		return err
	}
	return os.WriteFile(c.Out, buf.Bytes(), dirInfo.Mode()&^0o111)
}
